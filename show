#!/bin/bash

# Shared color definitions and utility functions for demo scripts
# Source this file in other scripts with: source "$(dirname "$0")/colors.sh"

# Base color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GREY='\033[0;90m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color
ITALIC='\033[3m'
BOLD='\033[1m'

# Load theme.sh from demo directory if it exists
if [ -f "$(dirname "$0")/theme.sh" ]; then
    source "$(dirname "$0")/theme.sh" 2>/dev/null || true
fi

# Semantic color definitions (configurable)
C_HEADER=${C_HEADER:-$CYAN}
C_HEADER_TEXT=${C_HEADER_TEXT:-$WHITE$BOLD}
C_SUCCESS=${C_SUCCESS:-$GREEN}
C_ERROR=${C_ERROR:-$RED}
C_WARNING=${C_WARNING:-$YELLOW}
C_INFO=${C_INFO:-$BLUE}
C_DEBUG=${C_DEBUG:-$PURPLE}
C_COMMAND=${C_COMMAND:-$RED}
C_COMMAND_TEXT=${C_COMMAND_TEXT:-$WHITE}
C_DEBUG_TEXT=${C_DEBUG_TEXT:-$GREY$ITALIC}
C_TEXT=${C_TEXT:-$YELLOW}
C_BULLET=${C_BULLET:-$GREEN}
C_PROMPT=${C_PROMPT:-$DIM$CYAN}
C_INTERACTIVE=${C_INTERACTIVE:-$PURPLE}
C_SEPARATOR=${C_SEPARATOR:-$DIM$CYAN}

# Configurable symbols
S_BULLET=${S_BULLET:-"➤"}
S_SUCCESS=${S_SUCCESS:-"✓"}
S_INFO=${S_INFO:-"ℹ"}
S_WARNING=${S_WARNING:-"⚠"}
S_ERROR=${S_ERROR:-"✗"}
S_DEBUG=${S_DEBUG:-"$"}
S_COMMAND=${S_COMMAND:-"$"}

debug_info() {
    echo "DEBUG: $DEBUG"
    echo "DRYRUN: $DRYRUN"
    echo "EXPORT: $EXPORT"
    echo "EXPORT_FORMAT: $EXPORT_FORMAT"
    echo "QUIET: $QUIET"
}

_check_env() {
    if [[ "$EXPORT_FORMAT" != "" ]]; then
        # Validate EXPORT_FORMAT has valid values
        if [[ "$EXPORT_FORMAT" = "sh" ]] || [[ "$EXPORT_FORMAT" = "md" ]]; then
            EXPORT=true
        else
            echo "ERROR: EXPORT_FORMAT must be 'sh' or 'md', got: '$EXPORT_FORMAT'"
            debug_info
            exit 1
        fi
    fi

    # EXPORT can't be set with QUIET and DRYRUN
    # exit if set together
    if [ "$EXPORT" = "true" ] && [ "$QUIET" = "true" ] && [ "$DRYRUN" = "true" ]; then
        echo "ERROR: EXPORT can't be set with QUIET and DRYRUN"
        debug_info
        exit 1
    fi
}

_check_env

_export_sh_header() {
    echo "#!/bin/bash"
    echo
    echo "# Generated by showtime.sh"
    echo
}

_export_header() {
    if [ "$EXPORT" = "true" ]; then
        _export_sh_header
    elif [ "$EXPORT_FORMAT" = "md" ]; then
        _export_md_noop
    fi
}

_export_header

# Global history file for demo commands
DEMO_HISTFILE=$(mktemp)

_print_sigint_ctrl_c() {
    if [ "$EXPORT" = "true" ]; then
        _export_sh_noop
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo -e "\n${C_INTERACTIVE}Ctrl+C detected - press Ctrl+C again within 2 seconds to exit demo${NC}"
    fi
}

_print_entering_bash() {
    if [ "$EXPORT" = "true" ]; then
        _export_sh_noop
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo -e "${C_INTERACTIVE}Entering bash...${NC}\n"
    fi
}

_print_exiting_bash() {
    if [ "$EXPORT" = "true" ]; then
        _export_sh_noop
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo -e "${C_INTERACTIVE}Exiting bash...${NC}\n"
    fi
}

_print_press_enter_to_continue() {
    if [ "$EXPORT" = "true" ]; then
        _export_sh_noop
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo -e "${DIM}${CYAN}Press Enter to continue...${NC}"
    fi
}

_print_header() {
    if [ "$EXPORT" = "true" ]; then
        if [ -z "$EXPORT_FORMAT" ]; then
            _export_sh_header "$@"
        elif [ "$EXPORT_FORMAT" = "sh" ]; then
            _export_sh_header "$@"
        elif [ "$EXPORT_FORMAT" = "md" ]; then
            _export_md_header "$@"
        else
            _export_sh_header "$@"
        fi
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo -e "${C_HEADER}========================================${NC}"
        echo -e "${C_HEADER_TEXT}$@${NC}"
        echo -e "${C_HEADER}========================================${NC}\n"
    fi
}

_print_first_line() {
    if [ "$EXPORT" = "true" ]; then
        if [ -z "$EXPORT_FORMAT" ]; then
            _export_sh_comment "$@"
        elif [ "$EXPORT_FORMAT" = "sh" ]; then
            _export_sh_comment "$@"
        elif [ "$EXPORT_FORMAT" = "md" ]; then
            _export_md_comment "$@"
        else
            _export_sh_comment "$@"
        fi
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo -e "${C_BULLET}${S_BULLET}${NC} ${C_TEXT}$@${NC}"
    fi
}


_print_line() {
    if [ "$EXPORT" = "true" ]; then
        if [ -z "$EXPORT_FORMAT" ]; then
            _export_sh_comment "$@"
        elif [ "$EXPORT_FORMAT" = "sh" ]; then
            _export_sh_comment "$@"
        elif [ "$EXPORT_FORMAT" = "md" ]; then
            _export_md_comment "$@"
        else
            _export_sh_comment "$@"
        fi
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo -e "  ${C_TEXT}$@${NC}"
    fi
}

_print_newline() {
    if [ "$EXPORT" = "true" ]; then
        echo
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo
    fi
}

_clear() {
    if [ "$EXPORT" = "true" ]; then
        _export_sh_noop
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        clear
    fi
}

_print_success() {
    if [ "$EXPORT" = "true" ]; then
        if [ -z "$EXPORT_FORMAT" ]; then
            _export_sh_comment "$@"
        elif [ "$EXPORT_FORMAT" = "sh" ]; then
            _export_sh_comment "$@"
        elif [ "$EXPORT_FORMAT" = "md" ]; then
            _export_md_comment "$@"
        else
            _export_sh_comment "$@"
        fi
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo -e "\n${C_SUCCESS}${S_SUCCESS}${NC} ${C_HEADER_TEXT}$@${NC}\n"
    fi
}

_print_error() {
    if [ "$EXPORT" = "true" ]; then
        if [ -z "$EXPORT_FORMAT" ]; then
            _export_sh_comment "ERR: $@"
        elif [ "$EXPORT_FORMAT" = "sh" ]; then
            _export_sh_comment "ERR: $@"
        elif [ "$EXPORT_FORMAT" = "md" ]; then
            _export_md_comment "ERR: $@"
        else
            _export_sh_comment "ERR: $@"
        fi
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo -e "\n${C_ERROR}${S_ERROR}${NC} ${C_HEADER_TEXT}ERR: $@${NC}\n"
    fi
}

_print_warning() {
    if [ "$EXPORT" = "true" ]; then
        if [ -z "$EXPORT_FORMAT" ]; then
            _export_sh_comment "WRN: $@"
        elif [ "$EXPORT_FORMAT" = "sh" ]; then
            _export_sh_comment "WRN: $@"
        elif [ "$EXPORT_FORMAT" = "md" ]; then
            _export_md_comment "WRN: $@"
        else
            _export_sh_comment "WRN: $@"
        fi
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo -e "\n${C_WARNING}${S_WARNING}${NC} ${C_HEADER_TEXT}WRN: $@${NC}\n"
    fi
}

_print_info() {
    if [ "$EXPORT" = "true" ]; then
        if [ -z "$EXPORT_FORMAT" ]; then
            _export_sh_comment "INF: $@"
        elif [ "$EXPORT_FORMAT" = "sh" ]; then
            _export_sh_comment "INF: $@"
        elif [ "$EXPORT_FORMAT" = "md" ]; then
            _export_md_comment "INF: $@"
        else
            _export_sh_comment "INF: $@"
        fi
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo -e "${C_INFO}${S_INFO}${NC} ${C_COMMAND_TEXT}INF: $@${NC}"
    fi
}

_print_separator() {
    if [ "$EXPORT" = "true" ]; then
        if [ -z "$EXPORT_FORMAT" ]; then
            _export_sh_comment "----------------------------------------"
        elif [ "$EXPORT_FORMAT" = "sh" ]; then
            _export_sh_comment "----------------------------------------"
        elif [ "$EXPORT_FORMAT" = "md" ]; then
            _export_md_comment "---"
        else
            _export_sh_comment "----------------------------------------"
        fi
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo -e "${C_SEPARATOR}----------------------------------------${NC}"
    fi
}

_print_debug_short_separator() {
    if [ "$DEBUG" = "true" ]; then
        echo -e "${C_DEBUG}---${NC}"
    fi
}

_print_command() {
    # Print command with $ in front
    # if EXPORT is true, print the command as a comment
    # if QUIET is true, do not print the command
    # if DRYRUN is true, print the command
    # _print_command will understand the EXPORT, QUIET, and DRYRUN vars

    # Examples:
    # _print_command "echo 'This is a command'"
    # $ echo 'This is a command'
    # EXPORT=true _print_command "echo 'This is a command'"
    # # echo 'This is a command'
    # QUIET=true _print_command "echo 'This is a command'"
    # DRYRUN=true _print_command "echo 'This is a command'"
    # echo 'This is a command'

    if [ "$EXPORT" = "true" ]; then
        if [ -z "$EXPORT_FORMAT" ]; then
            _export_sh_command "$@"
        elif [ "$EXPORT_FORMAT" = "sh" ]; then
            _export_sh_command "$@"
        elif [ "$EXPORT_FORMAT" = "md" ]; then
            _export_md_command "$@"
        else
            _export_sh_command "$@"
        fi
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        echo -e "${C_COMMAND}${S_COMMAND}${NC} ${C_COMMAND_TEXT}$@${NC}"
    fi
}

_print_debug() {
    if [ "$DEBUG" = "true" ]; then
        echo -e "${C_DEBUG}${S_DEBUG}${NC} ${C_DEBUG_TEXT}$@${NC}"
    fi
}

# Signal handling for Ctrl+C
handle_sigint() {
    _print_sigint_ctrl_c

    # Temporarily change trap to exit on second Ctrl+C
    trap 'echo -e "\n${C_ERROR}Double Ctrl+C - exiting demo${NC}"; exit 130' SIGINT

    # Wait 2 seconds for second Ctrl+C, then enter interactive mode
    sleep 2
    trap 'handle_sigint' SIGINT
    _print_entering_bash
    b
    _print_press_enter_to_continue
}

# --- --- --- Export functions --- --- ---

# --- --- Export functions for markdown --- ---
_export_md_comment() {
    # Export input as a comment for markdown
    #
    # Example:
    # _export_md_comment "This is a comment"
    # # This is a comment
    echo "$@" | fold -s -w 78
}

_export_md_command() {
    # Export input as a command for markdown
    #
    # Example:
    # _export_md_command "echo 'This is a command'"
    # ```bash
    # echo 'This is a command'
    # ```
    echo "\`\`\`bash"
    echo "$@"
    echo "\`\`\`"
    echo
}

_export_md_header() {
    # Export input as a header for markdown
    #
    # Example:
    # _export_md_header "This is a header"
    # # ========================================"
    # #  This is a header
    # # ========================================"
    echo "# $1"
    echo
}

_export_md_noop () {
    # Do nothing
    :  # do nothing
}

# --- --- --- Export functions for shell --- --- ---
_export_sh_comment() {
    # Export input as a comment for shell
    #
    # Example:
    # _export_sh_comment "This is a comment"
    # # This is a comment
    echo "$@" | fold -s -w 78 | sed 's/^/# /'
}

_export_sh_command() {
    # Export input as a command for shell
    #
    # Example:
    # _export_sh_command "echo 'This is a command"
    # echo 'This is a command'
    echo "$@"
    echo
}

_export_sh_header() {
    # Export input as a header for shell
    #
    # Example:
    # _export_sh_header "This is a header"
    # # ========================================"
    # #  This is a header
    # # ========================================"
    echo "# ========================================"
    echo "#  $1"
    echo "# ========================================"
    echo
}

_export_sh_noop() {
    # Do nothing
    :  # do nothing
}

# Set up the trap
trap 'handle_sigint' SIGINT

# Function to print colored headers
h() {
    _clear
    hh "$1"
}

hh() {
    if [ "$QUIET" != "true" ]; then
        _print_header "$1"
    fi
}

# print a debug message
d() { 
    _print_debug "$@"
}

# Function to print step messages
p() {
    local first_line=true
    echo "$1" | fold -s -w 78 | while IFS= read -r line; do
        if [ "$first_line" = true ]; then
            _print_first_line $line
            first_line=false
        else
            _print_line $line
        fi
    done
    _print_newline
}

# Function to print success messages
ps() {
    _print_success "$@"
}

# Function to print error messages
pe() {
    _print_error "$@"
}

# Function to print warning messages
pw() {
    _print_warning "$@"
}

# Function to print info messages
pi() {
    _print_info "$@"
}

# Function to print section separators
p-() {
    _print_separator "$@"
}

# Function to print command in red and execute it
# put a newline at the end
e() {
    # Print command and run it
    # if EXPORT is true, just print the command
    # if QUIET is true, do not print the command but still run it
    # if DRYRUN is true, print the command do not run it
    # _print_command will understand the EXPORT, QUIET, and DRYRUN vars
    _print_command $1
    if [ "$EXPORT" = "true" ] || [ "$DRYRUN" = "true" ]; then
        return
    fi

    # Append command to global history file
    echo "$1" >> "$DEMO_HISTFILE"

    if [ "$QUIET" = "true" ]; then  
        # run command and redirect its output to /dev/null
        HISTFILE="$DEMO_HISTFILE" bash -c "$1" >/dev/null 2>&1
    else
        # Execute with HISTFILE set
        HISTFILE="$DEMO_HISTFILE" bash -c "$1"
    fi
    local exit_code=$?
    _print_newline
    return $exit_code
}

# Function to print command in red and execute it with timeout
et() {
    _print_command $1
    if [ "$EXPORT" = "true" ] || [ "$DRYRUN" = "true" ]; then
        return
    fi

    local timeout_duration="${2:-30}"  # Default 30 seconds

    # Append command to global history file
    echo "$1" >> "$DEMO_HISTFILE"

    if [ "$QUIET" = "true" ]; then
        # run command and redirect its output to /dev/null
        HISTFILE="$DEMO_HISTFILE" timeout "$timeout_duration" bash -c "$1" 2>&1 >/dev/null
    else
        HISTFILE="$DEMO_HISTFILE" timeout "$timeout_duration" bash -c "$1"
    fi
    local exit_code=$?
    if [ $exit_code -eq 124 ]; then
        pw "Command timed out after ${timeout_duration} seconds"
    fi
}

ed() {
    _print_debug_short_separator
    _print_debug "$1"
    _print_debug_short_separator
    echo "$1" >> "$DEMO_HISTFILE"

    HISTFILE="$DEMO_HISTFILE" bash -c "$1"
    local exit_code=$?
    _print_newline
    return $exit_code
}
# Function to pause demo execution based on GOON variable
w() {
    if [ "${GOON:-false}" = "true" ]; then
        # If GOON is true, continue without pausing
        return
    elif [ "$EXPORT" = "true" ]; then
        _export_sh_noop
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        # If GOON is false or not set, wait for user input
        _print_press_enter_to_continue
        read -r
    fi
}

b() {
    if [ "$EXPORT" = "true" ]; then
        _export_sh_noop
    elif [ "$QUIET" = "true" ]; then
        _export_sh_noop
    else
        if [ -z "$DEMO_NAME" ]; then
            DEMO=demo
        else
            DEMO=$DEMO_NAME
        fi
        HISTFILE="$DEMO_HISTFILE" PS1="\[${C_INTERACTIVE}\]($DEMO) \$ \[${NC}\]" bash --rcfile <(
            echo "set +h"
            echo "history -r '$DEMO_HISTFILE'"
            echo "trap 'history -w \"$DEMO_HISTFILE\"' EXIT"
            echo "# Load bash completion"
            echo "if [ -f /etc/bash_completion ]; then"
            echo "    . /etc/bash_completion"
            echo "elif [ -f /usr/share/bash-completion/bash_completion ]; then"
            echo "    . /usr/share/bash-completion/bash_completion"
            echo "fi"
        )
        _print_exiting_bash
    fi
}

# =========================================================================== #

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then

# Function to display usage
usage() {
    echo "Usage: $0 <demo_name> [--clean|-y]"
    echo "Examples:"
    echo "  $0 mydemo            # Run demo mydemo"
    echo "  $0 mydemo --clean    # Clean demo mydemo"
    echo "  $0 mydemo -y         # Run demo mydemo without pausing"
    echo "  $0 mydemo --dryrun   # Run everything without executing"
    echo "  $0 mydemo --export   # Export demo to stdout"
    echo "  $0 mydemo --offline  # Run demo mydemo offline steps (if defined)"
    echo "  $0 mydemo --quiet    # Run without printing anything"
    exit 1
}

# Check if at least one argument is provided
if [ $# -eq 0 ]; then
    usage
fi

DEMO_NAME=$1
CLEAN_MODE=false

# Initialize GOON variable
GOON=false

# Check for --clean or -y flag
if [ $# -eq 2 ]; then
    if [ "$2" = "--clean" ]; then
        CLEAN_MODE=true
    elif [ "$2" = "-y" ]; then
        GOON=true
    elif [ "$2" = "--export" ]; then
        GOON=true
        EXPORT=true
    elif
        [ "$2" = "--offline" ]; then
        OFFLINE=true
    elif
        [ "$2" = "--quiet" ]; then
        QUIET=true
    elif
        [ "$2" = "--dfryrun" ]; then
        DRYRUN=true
    else
        usage
    fi
elif [ $# -gt 2 ]; then
    usage
fi

# Validate demo number
# case $DEMO_NAME in
#     ansible|autocompletion|auto-update|compose|healthcheck|quadlet|auto-update-rollback)
#         ;;
#     *)
#         echo "Error: Invalid demo name '$DEMO_NAME'"
#         echo "Valid demos are: ansible, autocompletion, auto-update, auto-update-rollback compose, farm, healthckeck"
#         exit 1
#         ;;
# esac

DEMO_DIR="./$DEMO_NAME"

# Check if demo directory exists
if [ ! -d "$DEMO_DIR" ]; then
    echo "Error: Demo directory '$DEMO_DIR' does not exist"
    exit 1
fi

if [ "$CLEAN_MODE" = true ]; then
    # Clean mode
    CLEAN_SCRIPT="$DEMO_DIR/clean.sh"
    if [ -f "$CLEAN_SCRIPT" ]; then
        echo "Running clean script for demo $DEMO_NAME..."
        cd "$DEMO_DIR" && source clean.sh
    else
        echo "Warning: Clean script '$CLEAN_SCRIPT' not found"
        exit 1
    fi
elif [ "$OFFLINE" = true ]; then
    OFFLINE_SCRIPT="$DEMO_DIR/offline.sh"
    if [ -f "$OFFLINE_SCRIPT" ]; then
        echo "Running offline steps for demo $DEMO_NAME..."
        cd "$DEMO_DIR" && source offline.sh
        exit 1
    fi
else
    # Run mode
    DEMO_SCRIPT="$DEMO_DIR/demo.sh"
    if [ -f "$DEMO_SCRIPT" ]; then
        echo "Running demo $DEMO_NAME..."
        cd "$DEMO_DIR" && GOON="$GOON" \
            EXPORT="$EXPORT" \
            DEMO_NAME="$DEMO_NAME" \
            source demo.sh
    else
        echo "Warning: Demo script '$DEMO_SCRIPT' not found"
        exit 1
    fi
fi

fi # BASH_SOURCE
